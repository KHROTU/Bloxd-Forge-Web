<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Materialize - TPack Editor</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      height: 100vh;
      margin: 0;
      background-color: #181818;
      color: #fff;
    }

    body.blurred {
      filter: blur(5px);
    }

    #sidebar {
      width: 200px;
      background-image: linear-gradient(to bottom, #282828, #151515);
      border: 1px solid #28282885;
      padding: 10px;
      overflow-y: auto;
      border-radius: 10px;
      margin: 10px;
    }

    #sidebar ul {
      list-style-type: none;
      padding: 0;
    }

    #sidebar li {
      padding: 5px;
      cursor: pointer;
      border-radius: 5px;
    }

    #sidebar li:hover {
      background-color: #444;
    }

    #canvas-container {
      flex-grow: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
      background-color: #111;
      border-radius: 10px;

    }

    canvas {
      background-image: linear-gradient(to bottom, #171717, #151515);
      border: 0.6px solid #28282885;
      cursor: crosshair;
      border-radius: 5px;
      transition: all 0.4s;
    }

    canvas:hover {
      cursor: crosshair;
      border: 0.6px solid #e67300;
    }


    #toolbar {
      width: 200px;
      background-image: linear-gradient(to bottom, #282828, #151515);
      border: 1px solid #28282885;
      padding: 10px;
      color: #fff;
      border-radius: 10px;
    }

    #toolbar button {
      width: 100%;
      padding: 10px;
      margin: 2px 0;
      color: #fff;
      background-image: linear-gradient(to bottom, #181818, #151515);
      border: 1px solid #28282885;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 5px;

    }

    #toolbar button:hover {
      border: 1px solid #e67300;
    }


    #upload-folder-btn {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      color: #fff;
      background-image: linear-gradient(to bottom, #181818, #151515);
      border: 1px solid #28282885;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 5px;
    }

    #upload-folder-btn:hover {
      border: 1px solid #e67300;
    }

    #color-picker {
      background-image: linear-gradient(to bottom, #181818, #151515);
      width: 100%;
      height: 45px;
      padding: 5px;
      border: none;
      margin-top: 10px;
      outline: none;
      transition-duration: 0.2s;
      border-radius: 5px;
    }


    #color-picker:hover {
      outline: none;
      border-color: #e67300;
    }

    #color-picker:focus {
      outline: none;
      border-color: #e67300;
    }

    #color-palette {
      margin-top: 20px;
      text-align: center;
    }

    #custom-colors {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 10px;
      gap: 5px;
    }

    #custom-colors .color-box {
      width: 30px;
      height: 30px;
      cursor: pointer;
      border: 2px solid #555;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      border-radius: 5px;
    }

    #custom-colors .color-box:hover {
      border: 2px solid #fff;
    }

    #color-input {
      margin-top: 10px;
      width: 80%;
      background-image: linear-gradient(to bottom, #181818, #151515);
      border: 1px solid #28282885;
      border-radius: 5px;
    }

    #color-input:hover {
      outline: none;
      border-color: #e67300;
    }

    #color-input:focus {
      outline: none;
      border-color: #e67300;
    }

    #add-color-btn {
      margin-top: 5px;
      width: 82%;
      padding: 10px;
      margin: 5px;
      color: #fff;
      background-image: linear-gradient(to bottom, #181818, #151515);
      border: 1px solid #28282885;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 5px;
    }

    #add-color-btn:hover {
      border: 1px solid #e67300;
    }

    ::-webkit-scrollbar {
      width: 8px;
      border-radius: 5px;
    }

    ::-webkit-scrollbar-track {
      background: #222;
      border-radius: 5px;
    }

    ::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 10px;
      transition-duration: 0.5;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #888;
    }


    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 120px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -60px;
      opacity: 0;
      transition: opacity 0.3s;
    }



    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #error-message {
      color: #ff6b6b;
      text-align: center;
      margin-top: 20px;
      display: none;
    }

    .color-input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 10px;
    }

    .color-text-input {
      width: 93.5%;
      padding: 5px;
      background-image: linear-gradient(to bottom, #181818, #151515);
      color: #fff;
      border: 1px solid #38383885;
      border-radius: 5px;
      text-align: center;
      text-transform: uppercase;
    }

    .color-text-input:focus {
      outline: none;
      border-color: #e67300;
    }

    .color-text-input.invalid {
      border-color: #ff6b6b;
    }
  </style>
</head>

<body>
  <div id="loading-overlay">
    <div id="loading-spinner"></div>
  </div>
  <div id="error-message">
    An error occurred. Please try again.
  </div>
  <div id="sidebar">
    <h3>Textures:</h3>
    <ul id="file-list"></ul>
    <button id="upload-folder-btn">Upload Textures</button>
    <input type="file" id="folder-input" accept="image/png" multiple directory style="display: none;" />
  </div>
  <div id="canvas-container">
    <canvas id="canvas" width="500" height="500"></canvas>
  </div>
  <div id="toolbar">
    <div class="color-picker-container">
      <input type="color" id="color-picker">
      <div class="color-input-container">
        <input type="text" id="color-text-input" class="color-text-input" maxlength="7" placeholder="Hex Color">
      </div>
    </div>
    <button id="undo-btn">Undo</button>
    <button id="darken-tool">Darken</button>
    <button id="lighten-tool">Lighten</button>
    <button id="eraser-tool">Eraser</button>
    <button id="eyedropper-tool">Eyedropper</button>
    <button id="pencil-tool">Pencil</button>
    <button id="save-btn">Save Texture</button>
  </div>

  <div id="color-palette">
    <h4>Colors:</h4>
    <div id="custom-colors"></div>
    <input type="color" id="color-input" />
    <button id="add-color-btn">Add Color</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  <script>
    let selectedTexture = null;
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let folderInput = document.getElementById('folder-input');
    let fileList = document.getElementById('file-list');
    let darkenTool = document.getElementById('darken-tool');
    let lightenTool = document.getElementById('lighten-tool');
    let eraserTool = document.getElementById('eraser-tool');
    let pencilTool = document.getElementById('pencil-tool');
    let saveBtn = document.getElementById('save-btn');
    let colorPicker = document.getElementById('color-picker');

    let currentTool = null;
    let currentColor = '#FFFFFF';
    let texturePixelSize = 1;
    let textureWidth = 16;
    let textureHeight = 16;

    document.getElementById('upload-folder-btn').addEventListener('click', () => {
      folderInput.click();
    });

    folderInput.addEventListener('change', enhancedHandleFiles, false);

    function handleFiles(event) {
      let files = event.target.files;
      fileList.innerHTML = '';
      let textures = [];
      Array.from(files).forEach(file => {
        if (file.type === 'image/png') {
          const fileReader = new FileReader();
          fileReader.onload = function (e) {
            let img = new Image();
            img.src = e.target.result;
            img.onload = function () {
              textures.push(img);
              let listItem = document.createElement('li');
              listItem.textContent = file.name;
              listItem.onclick = () => loadTexture(img);
              fileList.appendChild(listItem);
            };
          };
          fileReader.readAsDataURL(file);
        }
      });
    }

    function loadTexture(img) {
      selectedTexture = img;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(selectedTexture, 0, 0, canvas.width, canvas.height);

      let textureSize = prompt("Enter the texture size (8x8 or 16x16):");
      if (textureSize === "8x8") {
        textureWidth = 8;
        textureHeight = 8;
        texturePixelSize = 62;
      } else if (textureSize === "16x16") {
        textureWidth = 16;
        textureHeight = 16;
        texturePixelSize = 30;
      } else {
        alert("Invalid size. Using default 16x16.");
        textureWidth = 16;
        textureHeight = 16;
        texturePixelSize = 30;
      }
    }

    darkenTool.addEventListener('mousedown', () => currentTool = 'darken');
    lightenTool.addEventListener('mousedown', () => currentTool = 'lighten');
    eraserTool.addEventListener('mousedown', () => currentTool = 'eraser');
    pencilTool.addEventListener('mousedown', () => currentTool = 'pencil');

    colorPicker.addEventListener('input', (e) => {
      currentColor = e.target.value;
    });

    let undoStack = [];
    const MAX_UNDO_STEPS = 50;

    function trackAction(action) {
      if (undoStack.length >= MAX_UNDO_STEPS) {
        undoStack.shift();
      }
      undoStack.push(action);
    }

    canvas.addEventListener('mousedown', (e) => {
      const { offsetX, offsetY } = e;
      const pixelX = Math.floor(offsetX / (500 / selectedTexture.width));
      const pixelY = Math.floor(offsetY / (500 / selectedTexture.height));
      const x = pixelX * (500 / selectedTexture.width);
      const y = pixelY * (500 / selectedTexture.height);

      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(x, y, texturePixelSize, texturePixelSize);

      const originalPixelData = {
        x: x,
        y: y,
        imageData: imageData
      };

      if (currentTool === 'pencil') {
        ctx.fillStyle = currentColor;
        ctx.fillRect(x, y, texturePixelSize, texturePixelSize);
        trackAction(originalPixelData);
      } else if (currentTool === 'darken') {
        ctx.fillStyle = `rgba(${Math.max(0, imageData.data[0] - 50)}, ${Math.max(0, imageData.data[1] - 50)}, ${Math.max(0, imageData.data[2] - 50)}, ${imageData.data[3] / 255})`;
        ctx.fillRect(x, y, texturePixelSize, texturePixelSize);
        trackAction(originalPixelData);
      } else if (currentTool === 'lighten') {
        ctx.fillStyle = `rgba(${Math.min(255, imageData.data[0] + 50)}, ${Math.min(255, imageData.data[1] + 50)}, ${Math.min(255, imageData.data[2] + 50)}, ${imageData.data[3] / 255})`;
        ctx.fillRect(x, y, texturePixelSize, texturePixelSize);
        trackAction(originalPixelData);
      } else if (currentTool === 'eraser') {
        ctx.clearRect(x, y, texturePixelSize, texturePixelSize);
        trackAction(originalPixelData);
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (e.buttons === 1) {
        const { offsetX, offsetY } = e;
        const pixelX = Math.floor(offsetX / (500 / selectedTexture.width));
        const pixelY = Math.floor(offsetY / (500 / selectedTexture.height));
        const x = pixelX * (500 / selectedTexture.width);
        const y = pixelY * (500 / selectedTexture.height);

        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(x, y, texturePixelSize, texturePixelSize);

        if (currentTool === 'pencil') {
          ctx.fillStyle = currentColor;
          ctx.fillRect(x, y, texturePixelSize, texturePixelSize);
        } else if (currentTool === 'darken') {
          ctx.fillStyle = `rgba(${Math.max(0, imageData.data[0] - 50)}, ${Math.max(0, imageData.data[1] - 50)}, ${Math.max(0, imageData.data[2] - 50)}, ${imageData.data[3] / 255})`;
          ctx.fillRect(x, y, texturePixelSize, texturePixelSize);
        } else if (currentTool === 'lighten') {
          ctx.fillStyle = `rgba(${Math.min(255, imageData.data[0] + 50)}, ${Math.min(255, imageData.data[1] + 50)}, ${Math.min(255, imageData.data[2] + 50)}, ${imageData.data[3] / 255})`;
          ctx.fillRect(x, y, texturePixelSize, texturePixelSize);
        }
      }
    });

    document.getElementById('undo-btn').addEventListener('click', () => {
      if (undoStack.length > 0) {
        const lastAction = undoStack.pop();
        const ctx = canvas.getContext('2d');

        ctx.putImageData(lastAction.imageData, lastAction.x, lastAction.y);
      }
    });

    let customColors = [];
    let customColorsContainer = document.getElementById('custom-colors');
    let colorInput = document.getElementById('color-input');
    let addColorBtn = document.getElementById('add-color-btn');

    addColorBtn.addEventListener('click', () => {
      if (customColors.length >= 15) {
        alert('You can only add up to 15 custom colors.');
        return;
      }

      let color = colorInput.value;
      if (!customColors.includes(color)) {
        customColors.push(color);
        updateCustomColors();
      } else {
        alert('This color is already in the palette.');
      }
    });

    customColorsContainer.addEventListener('contextmenu', (e) => e.preventDefault());

    function updateCustomColors() {
      customColorsContainer.innerHTML = '';

      customColors.forEach((color, index) => {
        let colorBox = document.createElement('div');
        colorBox.className = 'color-box';
        colorBox.style.backgroundColor = color;

        colorBox.onclick = () => {
          currentColor = color;
          colorPicker.value = color;
        };

        colorBox.oncontextmenu = (e) => {
          e.preventDefault();
          customColors.splice(index, 1);
          updateCustomColors();
        };

        customColorsContainer.appendChild(colorBox);
      });
    }

    let eyedropperTool = document.getElementById('eyedropper-tool');

    eyedropperTool.addEventListener('mousedown', () => currentTool = 'eyedropper');

    saveBtn.addEventListener('click', () => {
      if (!selectedTexture) {
        alert('Please select a texture first!');
        return;
      }

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = selectedTexture.width;
      tempCanvas.height = selectedTexture.height;
      const tempCtx = tempCanvas.getContext('2d');

      tempCtx.imageSmoothingEnabled = false;
      tempCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, selectedTexture.width, selectedTexture.height);

      const originalFilename = selectedTexture.src.split('/').pop().split('?')[0];
      const link = document.createElement('a');
      link.download = originalFilename;
      link.href = tempCanvas.toDataURL('image/png');
      link.click();
    });

    canvas.addEventListener('click', (e) => {
      if (currentTool === 'eyedropper') {
        const { offsetX, offsetY } = e;
        const pixelData = ctx.getImageData(offsetX, offsetY, 1, 1).data;
        const [r, g, b] = pixelData;

        currentColor = `#${((1 << 24) | (r << 16) | (g << 8) | b).toString(16).slice(1)}`;
        colorPicker.value = currentColor;
      }
    });

    function showLoading() {
      document.getElementById('loading-overlay').style.display = 'flex';
    }

    function hideLoading() {
      document.getElementById('loading-overlay').style.display = 'none';
    }

    function showError(message) {
      const errorElement = document.getElementById('error-message');
      errorElement.textContent = message || 'An error occurred. Please try again.';
      errorElement.style.display = 'block';
      hideLoading();
    }

    function hideError() {
      document.getElementById('error-message').style.display = 'none';
    }

    function enhancedHandleFiles(event) {
      try {
        showLoading();
        hideError();
        handleFiles(event);
      } catch (error) {
        showError(error.message);
      } finally {
        hideLoading();
      }
    }

    Object.entries({
      'darken': document.getElementById('darken-tool'),
      'lighten': document.getElementById('lighten-tool'),
      'eraser': document.getElementById('eraser-tool'),
      'pencil': document.getElementById('pencil-tool'),
      'eyedropper': document.getElementById('eyedropper-tool')
    }).forEach(([toolName, button]) => {
      button.classList.add('tooltip');
      const tooltipSpan = document.createElement('span');
      tooltipSpan.classList.add('tooltiptext');
      tooltipSpan.textContent = toolName.charAt(0).toUpperCase() + toolName.slice(1);
      button.appendChild(tooltipSpan);
    });

    const colorTextInput = document.getElementById('color-text-input');

    colorTextInput.value = colorPicker.value;

    colorPicker.addEventListener('input', (e) => {
      currentColor = e.target.value;
      colorTextInput.value = e.target.value;
    });

    colorTextInput.addEventListener('input', (e) => {
      let input = e.target.value.trim();

      if (!input.startsWith('#')) {
        input = '#' + input;
      }

      const hexRegex = /^#([0-9A-Fa-f]{3}){1,2}$/;
      if (hexRegex.test(input)) {
        if (input.length === 4) {
          input = '#' + input[1].repeat(2) + input[2].repeat(2) + input[3].repeat(2);
        }

        colorPicker.value = input;
        currentColor = input;

        colorTextInput.classList.remove('invalid');
      } else {
        colorTextInput.classList.add('invalid');
      }
    });

    colorTextInput.addEventListener('paste', (e) => {
      e.preventDefault();
      const pastedText = e.clipboardData.getData('text').trim();
      colorTextInput.value = pastedText;
      colorTextInput.dispatchEvent(new Event('input'));
    });
  </script>
</body>

</html>