<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BloxdForge Coder</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <style>
        :root {
          --background-color: #181818;
          --surface-color: #282828;
          --primary-color: #ff8c42;
          --text-color: #e0e0e0;
          --border-color: #444;
          --user-msg-bg: #3a3a3a;
          --assistant-msg-bg: #2c2c2c;
          --code-bg: #1e1e1e;
        }
        body {
          font-family: "Segoe UI", sans-serif;
          display: flex;
          flex-direction: column;
          align-items: center;
          height: 100vh;
          margin: 0;
          padding: 10px;
          box-sizing: border-box;
          background-color: var(--background-color);
          color: var(--text-color);
        }
        #chatWrapper {
          width: 100%;
          max-width: 800px;
          display: flex;
          flex-direction: column;
          height: 100%;
          overflow: hidden;
        }
        #header {
          text-align: center;
          margin-bottom: 15px;
          flex-shrink: 0;
        }
        #header img {
          width: 80px;
        }
        #header h2 {
          margin-top: 5px;
          color: var(--primary-color);
        }
        #chatContainer {
          flex-grow: 1;
          overflow-y: auto;
          padding: 15px;
          border: 1px solid var(--border-color);
          border-radius: 8px;
          background-color: var(--surface-color);
          display: flex;
          flex-direction: column;
          gap: 15px;
        }
        .message {
          padding: 12px 18px;
          border-radius: 12px;
          max-width: 90%;
          word-wrap: break-word;
          line-height: 1.6;
        }
        .user-message {
          background-color: var(--user-msg-bg);
          align-self: flex-end;
        }
        .assistant-message {
          background-color: var(--assistant-msg-bg);
          align-self: flex-start;
        }
        .message.error {
          background-color: #5c3030;
          color: #ffcccc;
          font-weight: bold;
        }
        
        .assistant-message pre {
          position: relative;
          background-color: var(--code-bg);
          padding: 15px;
          padding-top: 40px;
          border-radius: 6px;
          margin: 10px 0;
          overflow-x: auto;
          border: 1px solid #333;
        }
        .assistant-message pre code {
          font-family: Consolas, Monaco, monospace;
          font-size: 0.9em;
        }
        .assistant-message .copy-btn {
          position: absolute;
          top: 8px;
          right: 8px;
          background: #444;
          color: #eee;
          border: none;
          padding: 5px 10px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 0.8em;
          opacity: 0.7;
        }
        .assistant-message .copy-btn:hover {
          background: #555;
          opacity: 1;
        }
        
        #inputContainer {
          flex-shrink: 0;
          display: flex;
          width: 100%;
          gap: 10px;
          padding-top: 15px;
        }
        #userInput {
          flex-grow: 1;
          padding: 12px;
          border: 1px solid var(--primary-color);
          border-radius: 8px;
          background-color: var(--surface-color);
          color: var(--text-color);
          font-size: 1em;
          resize: none;
        }
        button {
          padding: 12px 25px;
          border: none;
          border-radius: 8px;
          background-color: var(--primary-color);
          color: var(--background-color);
          cursor: pointer;
          font-size: 1em;
          font-weight: bold;
        }
        button:disabled {
          background-color: #555;
          color: #888;
          cursor: not-allowed;
        }
        button:hover:not(:disabled) {
          background-color: #e67e3f;
        }
        
        .spinner {
          border: 3px solid #555;
          border-top: 3px solid var(--primary-color);
          border-radius: 50%;
          width: 18px;
          height: 18px;
          animation: spin 1s linear infinite;
          display: inline-block;
          margin-left: 10px;
          vertical-align: middle;
        }
        @keyframes spin {
          0% {
            transform: rotate(0deg);
          }
          100% {
            transform: rotate(360deg);
          }
        }
        
        .think-box {
          border: 1px solid #4a4a4a;
          border-radius: 6px;
          margin: 12px 0;
          font-size: 0.9em;
          background: #222;
        }
        .think-header {
          cursor: pointer;
          padding: 8px 12px;
          display: flex;
          align-items: center;
          user-select: none;
          border-radius: 6px 6px 0 0;
        }
        .think-arrow {
          margin-right: 8px;
          transition: transform 0.2s;
          color: var(--primary-color);
          font-weight: bold;
        }
        .think-label {
          font-weight: bold;
          color: var(--primary-color);
        }
        .think-content {
          padding: 10px 14px;
          border-top: 1px solid #4a4a4a;
          color: #c0c0c0;
          font-family: Consolas, Monaco, monospace;
          white-space: pre-wrap;
          word-break: break-word;
          max-height: 0;
          overflow: hidden;
          transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        .think-box:not(.open) .think-content {
          padding-top: 0;
          padding-bottom: 0;
        }
        .think-box.open .think-content {
          max-height: 500px;
          overflow-y: auto;
        }
        .think-box.open .think-arrow {
          transform: rotate(90deg);
        }
    </style>
</head>
<body>
    <div id="chatWrapper">
        <div id="header">
            <img id="logo" src="spinner.png" alt="Logo">
            <h2>BloxdForge Coder</h2>
        </div>
        <div id="chatContainer"></div>
        <div id="inputContainer">
            <textarea id="userInput" placeholder="Describe the code you need..." rows="1" disabled></textarea>
            <button id="sendBtn" disabled>Send</button>
        </div>
    </div>

    <script>
        const ui = {
            chatContainer: document.getElementById('chatContainer'),
            input: document.getElementById('userInput'),
            sendBtn: document.getElementById('sendBtn'),
        };

        const state = {
            csrfToken: null, userId: null, chatHistory: [], isWaiting: false,
            messageIdCounter: 0, apiBaseUrl: 'https://khrotu.pythonanywhere.com', rateLimitSeconds: 3,
        };

        marked.setOptions({
            highlight: (code, lang) => hljs.highlight(code, { language: hljs.getLanguage(lang) ? lang : 'plaintext', ignoreIllegals: true }).value,
            gfm: true, breaks: true,
        });

        const getUserId = () => {
            let id = localStorage.getItem('userId');
            if (!id) {
                id = `user_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                localStorage.setItem('userId', id);
            }
            return id;
        };
        const scrollToBottom = () => ui.chatContainer.scrollTo({ top: ui.chatContainer.scrollHeight, behavior: 'smooth' });

        const appendMessage = (role, content, extraClass = '') => {
            const messageId = `msg-${state.messageIdCounter++}`;
            const messageDiv = document.createElement('div');
            messageDiv.id = messageId;
            messageDiv.className = `message ${role}-message ${extraClass}`;
            messageDiv.innerHTML = content;
            ui.chatContainer.appendChild(messageDiv);
            scrollToBottom();
            return messageId;
        };

        const updateMessage = (messageId, reasoningText, contentText, isStreamingThinking = false) => {
            const messageDiv = document.getElementById(messageId);
            if (!messageDiv) return;

            const thinkMatch = contentText.match(/<think>([\s\S]*?)<\/think>/);
            let finalReasoning = reasoningText;
            let finalContent = contentText;

            if (thinkMatch && thinkMatch[1]) {
                finalReasoning = (finalReasoning + '\n' + thinkMatch[1]).trim();
                finalContent = contentText.replace(thinkMatch[0], '').trim();
            }

            const contentHTML = marked.parse(finalContent);
            let thinkHTML = '';

            if (finalReasoning) {
                const existingThinkBox = messageDiv.querySelector('.think-box');
                let classes = ['think-box'];

                if (existingThinkBox?.classList.contains('user-touched')) {
                    classes.push('user-touched');
                    if (existingThinkBox.classList.contains('open')) {
                        classes.push('open');
                    }
                } else if (isStreamingThinking) {
                    classes.push('open');
                }
                
                const escapedReasoning = finalReasoning.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');

                thinkHTML = `
                    <div class="${classes.join(' ')}">
                        <div class="think-header">
                            <span class="think-arrow">â–¶</span>
                            <span class="think-label">Thinking Process</span>
                        </div>
                        <div class="think-content">${escapedReasoning}</div>
                    </div>`;
            }

            messageDiv.innerHTML = thinkHTML + contentHTML;

            messageDiv.querySelectorAll('pre:not(:has(.copy-btn))').forEach(pre => {
                const code = pre.querySelector('code');
                if (!code) return;
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-btn';
                copyButton.textContent = 'Copy';
                copyButton.onclick = () => {
                    navigator.clipboard.writeText(code.innerText);
                    copyButton.textContent = 'Copied!';
                    setTimeout(() => { copyButton.textContent = 'Copy'; }, 2000);
                };
                pre.appendChild(copyButton);
            });

            messageDiv.querySelectorAll('.think-header:not(.event-attached)').forEach(header => {
                header.classList.add('event-attached');
                header.onclick = () => {
                    const thinkBox = header.parentElement;
                    thinkBox.classList.toggle('open');
                    thinkBox.classList.add('user-touched');
                };
            });
            scrollToBottom();
        };

        const initializeChat = async () => {
            appendMessage('assistant', 'Hello! I can help you write JavaScript for the Bloxd.io API.');
            const statusId = appendMessage('assistant', 'Authenticating... <div class="spinner"></div>');
            try {
                state.userId = getUserId();
                const response = await fetch(`${state.apiBaseUrl}/get-csrf-token`, { headers: { 'X-User-ID': state.userId } });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({error: `Server responded with status ${response.status}`}));
                    throw new Error(errorData.error);
                }
                const data = await response.json();
                if (!data.csrf_token) throw new Error("No CSRF token received.");
                state.csrfToken = data.csrf_token;

                document.getElementById(statusId)?.remove();
                ui.input.disabled = false;
                ui.sendBtn.disabled = false;
                ui.input.placeholder = "Describe the code you need...";
                ui.input.focus();
            } catch (error) {
                const statusDiv = document.getElementById(statusId);
                if (statusDiv) {
                    statusDiv.classList.add('error');
                    statusDiv.innerHTML = `<strong>Security Error:</strong> Could not initialize. (${error.message})`;
                }
            }
        };

        const askCodeAgent = async () => {
            const userInput = ui.input.value.trim();
            if (!userInput || state.isWaiting || !state.csrfToken) return;

            state.isWaiting = true;
            ui.sendBtn.disabled = true;
            ui.input.disabled = true;

            state.chatHistory.push({ role: 'user', content: userInput });
            appendMessage('user', userInput);
            const assistantMsgId = appendMessage('assistant', 'Waiting for response... <div class="spinner"></div>');

            let accumulatedReasoning = "";
            let accumulatedContent = "";
            let hasStartedContent = false;

            try {
                const response = await fetch(`${state.apiBaseUrl}/api/code`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-User-ID': state.userId, 'X-CSRF-Token': state.csrfToken },
                    body: JSON.stringify({ messages: state.chatHistory }),
                });

                if (!response.ok || !response.body) {
                    const errorText = await response.text();
                    try {
                        const match = errorText.match(/data:\s*(\{.*\})\s*/);
                        const errorJson = JSON.parse(match[1]);
                        throw new Error(errorJson.error);
                    } catch { throw new Error(`Network response error: ${response.status} ${response.statusText}`); }
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    let boundary;
                    while ((boundary = buffer.indexOf('\n\n')) >= 0) {
                        const messageString = buffer.substring(0, boundary);
                        buffer = buffer.substring(boundary + 2);

                        if (messageString.startsWith('data: ')) {
                            const data = messageString.substring(6).trim();
                            if (data === '[DONE]') continue;
                            try {
                                const jsonData = JSON.parse(data);
                                const delta = jsonData.choices?.[0]?.delta;
                                if (delta) {
                                    if (delta.reasoning) {
                                        accumulatedReasoning += delta.reasoning;
                                    }
                                    if (delta.content) {
                                        accumulatedContent += delta.content;
                                        hasStartedContent = true;
                                    }
                                    const isStreamingThinking = accumulatedReasoning.length > 0 && !hasStartedContent;
                                    updateMessage(assistantMsgId, accumulatedReasoning, accumulatedContent, isStreamingThinking);
                                }
                            } catch (e) {
                                console.debug('Could not parse partial SSE chunk. Buffer will handle it.', data);
                            }
                        }
                    }
                }

                updateMessage(assistantMsgId, accumulatedReasoning, accumulatedContent, false);

                const finalContentToSave = accumulatedContent.replace(/<think>[\s\S]*?<\/think>/, '').trim();
                if (finalContentToSave || accumulatedReasoning) {
                    state.chatHistory.push({ role: 'assistant', content: accumulatedContent });
                } else {
                    updateMessage(assistantMsgId, "", "The AI returned an empty or invalid response.", false);
                }
            } catch (error) {
                console.error('Code Agent Error:', error);
                updateMessage(assistantMsgId, "", `**Error:** ${error.message}`, false);
            } finally {
                state.isWaiting = false;
                ui.input.disabled = false;
                ui.input.value = '';
                ui.input.style.height = 'auto';
                ui.input.focus();
                setTimeout(() => { ui.sendBtn.disabled = false; }, state.rateLimitSeconds * 1000);
            }
        };

        window.onload = () => {
            initializeChat();

            ui.sendBtn.addEventListener('click', askCodeAgent);
            ui.input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && !ui.sendBtn.disabled) {
                    e.preventDefault();
                    askCodeAgent();
                }
            });
            ui.input.addEventListener('input', () => {
                ui.input.style.height = 'auto';
                ui.input.style.height = `${ui.input.scrollHeight}px`;
            });
        };
    </script>
</body>
</html>